<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cortex Club Neural Sponsors</title>
<style>
  html, body {
    margin: 0; height: 100%;
    background: #ffffff; overflow: hidden;
    font-family: sans-serif;
  }
  canvas {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
  }

  .center, .sponsor {
    position: absolute;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    background: #fff;
    box-shadow: 0 0 15px rgba(42,82,190,0.2);
    border: none;
    user-select: none;
    text-align: center;
    transition: width 0.3s ease, height 0.3s ease, border-color 0.3s;
  }

  .center {
    width: 140px; height: 140px;
    z-index: 10; font-weight: 600;
    cursor: pointer;
  }

  .sponsor img {
    max-width: 100%; max-height: 100%;
    object-fit: contain; display: block;
    transition: transform 0.3s;
  }

  .sponsor:hover img { transform: scale(1.05); }

  .gold   { border-color: gold; }
  .silver { border-color: silver; }
  .bronze { border-color: #cd7f32; }
</style>
</head>
<body>

<canvas id="bg"></canvas>

<div class="center" id="center">Cortex Club</div>
<div class="sponsor gold" id="dpag"><img src="assets/sponser_logos/DPAG.png" alt="DPAG"></div>
<div class="sponsor silver" id="bna"><img src="assets/sponser_logos/BNA.png" alt="BNA"></div>
<div class="sponsor bronze" id="pharmacology"><img src="assets/sponser_logos/Department of Pharmacology.png" alt="Pharmacology"></div>
<div class="sponsor bronze" id="clinical-neuro"><img src="assets/sponser_logos/Department_of_Clinical_Neuroscience.png" alt="Clinical Neuro"></div>
<div class="sponsor bronze" id="experimental-psych"><img src="assets/sponser_logos/Department_of_Experimental_Psychology.jpeg" alt="Experimental Psych"></div>
<div class="sponsor bronze" id="psychiatry"><img src="assets/sponser_logos/Department_of_Psychiatry.png" alt="Psychiatry"></div>

<script>
const canvas = document.getElementById('bg');
const ctx = canvas.getContext('2d');
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;

const soma = {x: W/2, y: H/2, radius: 70};
const centerEl = document.getElementById('center');

const sponsors = [
  {el: document.getElementById('dpag'), tier:'gold'},
  {el: document.getElementById('bna'), tier:'silver'},
  {el: document.getElementById('pharmacology'), tier:'bronze'},
  {el: document.getElementById('clinical-neuro'), tier:'bronze'},
  {el: document.getElementById('experimental-psych'), tier:'bronze'},
  {el: document.getElementById('psychiatry'), tier:'bronze'}
];

const tiers = {
  gold:   {mass:2.0, repel:120000, attract:0.008, color:'#FFD700'},
  silver: {mass:1.5, repel:90000, attract:0.010, color:'#C0C0C0'},
  bronze: {mass:0.9, repel:70000, attract:0.012, color:'#CD7F32'}
};

const tierScales = { gold: 2.0, silver: 1.4, bronze: 1.0 };

// Scale sponsor logos by tier and aspect ratio
function adjustLogoSize(s) {
  const img = s.el.querySelector('img');
  if (!img.complete) { img.onload = () => adjustLogoSize(s); return; }
  const baseW = 120, baseH = 90;
  const aspect = img.naturalWidth / img.naturalHeight;
  const scale = Math.sqrt(tierScales[s.tier]);
  let width, height;
  if (aspect >= 1) {
    width = baseW * scale;
    height = (baseW / aspect) * scale;
  } else {
    height = baseH * scale;
    width = (baseH * aspect) * scale;
  }
  s.el.style.width = `${width}px`;
  s.el.style.height = `${height}px`;
}

// Intersection point between two rectangles (for dendrites)
function getBorderPoint(rectX, rectY, rectW, rectH, targetX, targetY) {
  const halfW = rectW / 2, halfH = rectH / 2;
  const dx = targetX - rectX, dy = targetY - rectY;
  const len = Math.sqrt(dx*dx + dy*dy) || 1;
  const unitX = dx / len, unitY = dy / len;
  const ratioX = halfW / Math.abs(unitX || 1);
  const ratioY = halfH / Math.abs(unitY || 1);
  const t = Math.min(ratioX, ratioY);
  return { x: rectX + unitX * t, y: rectY + unitY * t };
}

 // Initial positions
 sponsors.forEach(s=>{
   s.x = soma.x + (Math.random()-0.5)*600;
   s.y = soma.y + (Math.random()-0.5)*600;
  s.vx = 0; s.vy = 0;
  s.curveX = (s.x + soma.x)/2;
  s.curveY = (s.y + soma.y)/2;
  adjustLogoSize(s);
});

centerEl.style.left = soma.x + 'px';
centerEl.style.top = soma.y + 'px';

// Helper to convert hex to RGB
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : {r: 42, g: 82, b: 190};
}

// Pulse particles for hover
let pulses = [];

function spawnPulse(s) {
   const start = getBorderPoint(s.x, s.y, s.el.offsetWidth, s.el.offsetHeight, soma.x, soma.y);
   const end = getBorderPoint(soma.x, soma.y, centerEl.offsetWidth, centerEl.offsetHeight, s.x, s.y);
   pulses.push({start, end, progress:0, speed:0.02, color:tiers[s.tier].color});
 }

// Physics animation
function physics(){
  ctx.clearRect(0,0,W,H);

   // update pulses
   pulses = pulses.filter(p => {
     p.progress += p.speed;
     const t = p.progress;
     const cx = (p.start.x + p.end.x)/2;
     const cy = (p.start.y + p.end.y)/2;
     const x = (1-t)*(1-t)*p.start.x + 2*(1-t)*t*cx + t*t*p.end.x;
     const y = (1-t)*(1-t)*p.start.y + 2*(1-t)*t*cy + t*t*p.end.y;
     ctx.beginPath();
     ctx.arc(x,y,4,0,2*Math.PI);
     const rgb = hexToRgb(p.color);
     ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${1-t})`;
     ctx.fill();
     return t < 1;
   });

   // draw dendrites
   ctx.lineWidth = 1.5;
   sponsors.forEach(s=>{
     const rgb = hexToRgb(tiers[s.tier].color);
     ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.35)`;
    // attraction
    const dx = soma.x - s.x, dy = soma.y - s.y;
    const r2 = dx*dx + dy*dy, r = Math.sqrt(r2);
    const fG = tiers[s.tier].attract * r;
    const fxG = fG * dx/r, fyG = fG * dy/r;
     // repulsion
     let fxR=0, fyR=0;
     sponsors.forEach(o=>{
       if(o===s) return;
       const dx2 = s.x - o.x, dy2 = s.y - o.y;
       const dist2 = dx2*dx2 + dy2*dy2, dist = Math.sqrt(dist2)||1;
       // Get actual box dimensions for collision detection
       const sRect = s.el.getBoundingClientRect();
       const oRect = o.el.getBoundingClientRect();
       const minDist = (Math.max(sRect.width, sRect.height) + Math.max(oRect.width, oRect.height)) / 2 + 30;
       // Apply much stronger repulsion when too close
       const effectiveDist2 = Math.max(dist2, minDist * minDist * 0.5);
       const force = (tiers[s.tier].repel * tiers[o.tier].mass) / effectiveDist2;
       // Extra boost if very close
       const closenessFactor = dist < minDist ? (minDist / dist) : 1;
       fxR += (dx2/dist)*force*closenessFactor; fyR += (dy2/dist)*force*closenessFactor;
     });
     const fx = fxG + fxR, fy = fyG + fyR;
     s.vx += fx * 0.00003; s.vy += fy * 0.00003;
    s.vx *= 0.95; s.vy *= 0.95;
    s.x += s.vx; s.y += s.vy;
    s.curveX += ((s.x + soma.x)/2 - s.curveX)*0.05;
    s.curveY += ((s.y + soma.y)/2 - s.curveY)*0.05;

    const sRect = s.el.getBoundingClientRect();
    const cRect = centerEl.getBoundingClientRect();
    const start = getBorderPoint(s.x, s.y, sRect.width, sRect.height, soma.x, soma.y);
    const end = getBorderPoint(soma.x, soma.y, cRect.width, cRect.height, s.x, s.y);

    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.quadraticCurveTo(s.curveX, s.curveY, end.x, end.y);
    ctx.stroke();

    s.el.style.left = s.x + 'px';
    s.el.style.top = s.y + 'px';
  });

  requestAnimationFrame(physics);
}

physics();

// Hover interactivity
sponsors.forEach(s => {
  s.el.addEventListener('mouseenter', ()=>{
    pulses = [];
    spawnPulse(s);
    s.pulseInterval = setInterval(()=>spawnPulse(s), 700);
  });
  s.el.addEventListener('mouseleave', ()=>{
    clearInterval(s.pulseInterval);
  });
});

centerEl.addEventListener('mouseenter', ()=>{
  pulses = [];
  sponsors.forEach((s,i)=> setTimeout(()=>spawnPulse(s), i*150));
  centerEl.pulseInterval = setInterval(()=>{
    sponsors.forEach((s,i)=> setTimeout(()=>spawnPulse(s), i*150));
  }, 2000);
});
centerEl.addEventListener('mouseleave', ()=>{
  clearInterval(centerEl.pulseInterval);
});

// Responsive layout
window.addEventListener('resize', ()=>{
  const oldX = soma.x, oldY = soma.y;
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  soma.x = W/2; soma.y = H/2;
  centerEl.style.left = soma.x + 'px';
  centerEl.style.top = soma.y + 'px';
  const dx = soma.x - oldX, dy = soma.y - oldY;
  sponsors.forEach(s => { s.x += dx; s.y += dy; });
});
</script>

</body>
</html>